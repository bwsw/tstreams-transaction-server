/**
 * Generated by Scrooge
 *   version: 4.16.0
 *   rev: 0201cac9fdd6188248d42da91fd14c87744cc4a5
 *   built at: 20170421-124523
 */
package com.bwsw.tstreamstransactionserver.rpc

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object TransactionStates {
  
  case object Opened extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val value: Int = 1
    val name: String = "Opened"
    val originalName: String = "Opened"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeOpened = _root_.scala.Some(com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Opened)
  
  case object Updated extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val value: Int = 2
    val name: String = "Updated"
    val originalName: String = "Updated"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUpdated = _root_.scala.Some(com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Updated)
  
  case object Cancel extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val value: Int = 3
    val name: String = "Cancel"
    val originalName: String = "Cancel"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeCancel = _root_.scala.Some(com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Cancel)
  
  case object Invalid extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val value: Int = 4
    val name: String = "Invalid"
    val originalName: String = "Invalid"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInvalid = _root_.scala.Some(com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Invalid)
  
  case object Checkpointed extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val value: Int = 5
    val name: String = "Checkpointed"
    val originalName: String = "Checkpointed"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeCheckpointed = _root_.scala.Some(com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Checkpointed)

  case class EnumUnknownTransactionStates(value: Int) extends com.bwsw.tstreamstransactionserver.rpc.TransactionStates {
    val name: String = "EnumUnknownTransactionStates" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * @throws NoSuchElementException if the value is not found.
   */
  def apply(value: Int): com.bwsw.tstreamstransactionserver.rpc.TransactionStates =
    value match {
      case 1 => com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Opened
      case 2 => com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Updated
      case 3 => com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Cancel
      case 4 => com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Invalid
      case 5 => com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Checkpointed
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownTransactionStates(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): com.bwsw.tstreamstransactionserver.rpc.TransactionStates =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownTransactionStates(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[com.bwsw.tstreamstransactionserver.rpc.TransactionStates] =
    value match {
      case 1 => _SomeOpened
      case 2 => _SomeUpdated
      case 3 => _SomeCancel
      case 4 => _SomeInvalid
      case 5 => _SomeCheckpointed
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[com.bwsw.tstreamstransactionserver.rpc.TransactionStates] =
    name.toLowerCase match {
      case "opened" => _SomeOpened
      case "updated" => _SomeUpdated
      case "cancel" => _SomeCancel
      case "invalid" => _SomeInvalid
      case "checkpointed" => _SomeCheckpointed
      case _ => _root_.scala.None
    }

  lazy val list: List[com.bwsw.tstreamstransactionserver.rpc.TransactionStates] = scala.List[com.bwsw.tstreamstransactionserver.rpc.TransactionStates](
    com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Opened,
    com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Updated,
    com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Cancel,
    com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Invalid,
    com.bwsw.tstreamstransactionserver.rpc.TransactionStates.Checkpointed
  )
}



@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait TransactionStates extends ThriftEnum with Serializable